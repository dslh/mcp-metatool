# MCP Metatool

A powerful **tool composition platform** built on the Model Context Protocol (MCP). Create sophisticated composite tools by combining multiple MCP servers using familiar Python-like Starlark syntax.

## üéØ What is MCP Metatool?

MCP Metatool transforms the MCP ecosystem from individual tools into a **unified composition platform**. Instead of calling tools individually, you can create intelligent workflows that combine GitHub, Slack, databases, filesystems, and any other MCP server into a single powerful tool.

**Example: Automated Issue Management**
```python
# Create a saved tool that combines GitHub and Slack
issue = github.createIssue({
    "title": params.title,
    "body": params.description,
    "labels": ["bug", "high-priority"]
})

notification = slack.postMessage({
    "channel": "#dev-alerts",
    "text": f"üö® Critical issue created: {issue.html_url}"
})

result = {
    "issue_url": issue.html_url,
    "issue_number": issue.number,
    "notification_sent": True,
    "slack_ts": notification.ts
}
```

## ‚ú® Key Features

- üîó **Multi-Server Integration**: Connect and orchestrate multiple MCP servers seamlessly
- üêç **Starlark Scripting**: Write composite tools using familiar Python-like syntax
- üõ†Ô∏è **Tool Composition**: Combine GitHub, Slack, databases, filesystems, and more
- üìä **Data Processing**: Transform and route data between different services
- ‚úÖ **Production Ready**: Full test coverage, error handling, and validation
- üîÑ **Hot Reloading**: Create and update tools without server restarts
- üìã **Schema Validation**: Robust input validation with JSON Schema support

## Installation

```bash
go build -o mcp-metatool .
```

## Usage

The server communicates over stdio using the MCP protocol. Add it to your Claude Code configuration:

```json
{
  "mcpServers": {
    "mcp-metatool": {
      "type": "stdio",
      "command": "/path/to/mcp-metatool"
    }
  }
}
```

### Environment Variables

- `MCP_METATOOL_DIR`: Override the default storage directory (`~/.mcp-metatool`)

## MCP Server Proxying

The metatool can connect to upstream MCP servers and proxy their tools, making them available in Starlark scripts. This enables creating composite tools that combine functionality from multiple MCP servers.

### Configuration

Create a `servers.json` file in your metatool directory (`~/.mcp-metatool/servers.json` or `$MCP_METATOOL_DIR/servers.json`):

**Basic Example:**
```json
{
  "mcpServers": {
    "github": {
      "command": "mcp-server-github",
      "args": ["--token", "${GITHUB_TOKEN}"]
    },
    "slack": {
      "command": "mcp-server-slack",
      "args": []
    }
  }
}
```

**Advanced Example with Environment Variables:**
```json
{
  "mcpServers": {
    "github": {
      "command": "mcp-server-github", 
      "args": ["--token", "${GITHUB_TOKEN}", "--org", "${GITHUB_ORG}"],
      "env": {
        "DEBUG": "true",
        "RATE_LIMIT": "5000"
      }
    },
    "database": {
      "command": "/usr/local/bin/mcp-server-postgres",
      "args": ["--connection", "${DATABASE_URL}"],
      "env": {
        "POSTGRES_SSL": "require"
      }
    },
    "filesystem": {
      "command": "mcp-server-filesystem",
      "args": ["--allowed-dir", "${HOME}/projects"]
    }
  }
}
```

### Tool Filtering

Control which tools are exposed to agents while keeping all tools available for Starlark composition:

**Allowlist Mode (only specified tools exposed):**
```json
{
  "mcpServers": {
    "github": {
      "command": "mcp-server-github",
      "allowedTools": ["get_issue", "list_issues", "create_*"]
    }
  }
}
```

**Denylist Mode (specified tools hidden):**
```json
{
  "mcpServers": {
    "slack": {
      "command": "mcp-server-slack",
      "hiddenTools": ["admin_*", "delete_*", "dangerous_operation"]
    }
  }
}
```

**Wildcard Patterns:**
- `admin_*` matches `admin_user`, `admin_delete`, etc.
- `*_admin` matches `delete_admin`, `user_admin`, etc.
- `get_*_info` matches `get_user_info`, `get_repo_info`, etc.
- `*` matches any tool name

**Important Notes:**
- Use either `allowedTools` OR `hiddenTools`, not both
- Filtered tools remain available in Starlark scripts for composition
- Perfect for wrapping raw tools with processed versions

### Features

- **Environment Variable Expansion**: Use `${VAR}` syntax to reference environment variables in commands, args, and env values
- **Automatic Discovery**: Tools from connected servers are automatically discovered at startup
- **Per-Tool Filtering**: Fine-grained control over which tools are exposed to agents
- **Error Resilience**: Failed server connections don't prevent the metatool from starting
- **Clean Shutdown**: Proper cleanup of all upstream connections on exit

### Status

- ‚úÖ **Phase 1 Complete**: Configuration, connection management, and tool discovery
- ‚úÖ **Phase 2 Complete**: MCP server proxying with configurable tool visibility
- ‚úÖ **Phase 2+ Complete**: **Starlark integration for calling upstream tools as `serverName.toolName(params)`**
- üìã **Phase 3 Planned**: Advanced features like execution timeouts, audit trails, and performance optimizations

## üöÄ Quick Start

### 1. Basic Tool Composition

Call multiple MCP servers in a single Starlark script:

```python
# Using eval_starlark tool
echo_result = echo.echo({"message": "Hello from composition!"})
processed_data = {
    "response": echo_result["structured"]["result"],
    "timestamp": "2025-01-11",
    "processed_by": "starlark"
}
```

### 2. Create Composite Tools

Save reusable tools that combine multiple services:

```python
# Save a tool that processes GitHub issues
github_issue = github.getIssue({"number": params.issue_number})
analysis = {
    "title": github_issue.title,
    "priority": "high" if "urgent" in github_issue.title.lower() else "normal",
    "assignee_count": len(github_issue.assignees),
    "needs_attention": github_issue.state == "open" and len(github_issue.comments) == 0
}

if analysis.needs_attention:
    slack.postMessage({
        "channel": "#dev-team",
        "text": f"üîî Issue #{params.issue_number} needs attention: {github_issue.html_url}"
    })

result = analysis
```

### 3. Data Processing Workflows

Transform and route data between different systems:

```python
# Fetch data from API, process it, and store results
api_data = api.fetchData({"endpoint": params.source})
processed = []

for item in api_data.items:
    if item.status == "active":
        processed.append({
            "id": item.id,
            "name": item.name.upper(),
            "score": item.score * 1.2  # Apply boost
        })

# Store processed data
database.insert({
    "table": "processed_items",
    "data": processed
})

result = {"processed_count": len(processed), "source": params.source}
```

## Available Tools

### eval_starlark

Execute Starlark code with access to all connected MCP servers.

**Parameters:**
- `code` (string): The Starlark code to execute
- `params` (object, optional): Parameters available as `params` dict in the code

**Features:**
- üîó **Server Access**: Call any connected MCP server using `serverName.toolName(params)`
- üêç **Full Starlark**: Complete Python-like language with loops, conditionals, comprehensions
- üìä **Data Processing**: Built-in functions for transforming and analyzing data
- üîÑ **Real-time Execution**: Execute code immediately with live results

**Examples:**

Multi-server workflow:
```python
# Call multiple services and combine results
user_data = github.getUser({"username": params.username})
recent_issues = github.listIssues({"creator": params.username, "state": "open"})

summary = {
    "user": user_data.login,
    "public_repos": user_data.public_repos,
    "open_issues": len(recent_issues),
    "most_recent": recent_issues[0].title if recent_issues else None
}
```

### save_tool

Create or update a composite tool definition that can be executed later.

**Parameters:**
- `name` (string): Tool identifier
- `description` (string): Human-readable description of what the tool does
- `inputSchema` (object): JSON Schema for tool parameters
- `code` (string): Starlark implementation of the tool

**Example - GitHub Issue Processor:**
```javascript
{
  "name": "github_issue_processor",
  "description": "Analyzes GitHub issues and sends Slack notifications for urgent ones",
  "inputSchema": {
    "type": "object",
    "properties": {
      "repo": {"type": "string", "description": "Repository name (owner/repo)"},
      "issue_number": {"type": "integer", "description": "Issue number to process"}
    },
    "required": ["repo", "issue_number"]
  },
  "code": `
# Fetch issue details from GitHub
issue = github.getIssue({
    "owner": params.repo.split('/')[0],
    "repo": params.repo.split('/')[1], 
    "issue_number": params.issue_number
})

# Analyze issue priority
is_urgent = any(label.name in ['urgent', 'critical', 'P0'] for label in issue.labels)
is_stale = issue.state == 'open' and len(issue.comments) == 0

# Send Slack notification if urgent
notification_sent = False
if is_urgent:
    slack_result = slack.postMessage({
        "channel": "#urgent-issues",
        "text": f"üö® Urgent issue detected: {issue.title}\n{issue.html_url}"
    })
    notification_sent = True

result = {
    "issue_title": issue.title,
    "is_urgent": is_urgent,
    "is_stale": is_stale,
    "assignee_count": len(issue.assignees),
    "notification_sent": notification_sent,
    "issue_url": issue.html_url
}
`
}
```

### list_saved_tools

List all saved composite tool definitions.

**Parameters:** None

**Returns:** A list of saved tools with their names and descriptions.

**Example:**
```javascript
list_saved_tools()  // Returns: {"tools": [{"name": "greet_user", "description": "A simple greeting tool"}]}
```

### show_saved_tool

Show the complete definition of a saved tool including its code, schema, and metadata.

**Parameters:**
- `name` (string): The name of the tool to display

**Example:**
```javascript
show_saved_tool({"name": "greet_user"})  // Returns complete tool definition
```

### delete_saved_tool

Delete a saved tool definition from storage.

**Parameters:**
- `name` (string): The name of the tool to delete

**Example:**
```javascript
delete_saved_tool({"name": "greet_user"})  // Removes the tool (restart server to unregister)
```

### Dynamic Saved Tools

Once saved with `save_tool`, custom tools become available as regular MCP tools:

```javascript
// Call the GitHub issue processor tool
github_issue_processor({
  "repo": "microsoft/vscode", 
  "issue_number": 12345
})

// Returns: {
//   "issue_title": "Critical bug in editor",
//   "is_urgent": true,
//   "is_stale": false,
//   "assignee_count": 2,
//   "notification_sent": true,
//   "issue_url": "https://github.com/microsoft/vscode/issues/12345"
// }
```

## üéØ Use Cases

### DevOps Automation
- **Incident Response**: Combine monitoring alerts, GitHub issues, and Slack notifications
- **Deployment Pipelines**: Orchestrate builds, tests, and notifications across multiple services
- **Code Review Automation**: Analyze PRs, run checks, and update project management tools

### Data Workflows  
- **ETL Pipelines**: Extract from APIs, transform data, and load into databases
- **Report Generation**: Aggregate data from multiple sources and distribute results
- **Data Validation**: Check data quality across different systems and alert on issues

### Customer Success
- **Support Ticket Routing**: Analyze support requests and route to appropriate teams
- **Customer Onboarding**: Coordinate account setup across multiple platforms
- **Health Monitoring**: Track customer usage and trigger interventions

### Research & Analytics
- **Multi-Source Analysis**: Combine data from GitHub, JIRA, Slack, and databases
- **Automated Reporting**: Generate insights and distribute to stakeholders
- **Trend Detection**: Monitor metrics across services and identify patterns

## üß™ Testing

The project includes comprehensive test coverage:

```bash
# Run all tests
go test ./...

# Run with coverage
go test -cover ./...

# Run specific test suites
go test ./internal/starlark -v    # Starlark integration tests
go test ./internal/tools -v      # Tool composition tests
go test ./internal/proxy -v      # MCP server proxy tests
```

**Test Coverage:**
- ‚úÖ **450+ test cases** covering all major functionality
- ‚úÖ **Bridge integration** tests for server namespaces and tool functions
- ‚úÖ **End-to-end workflows** validating multi-server composition
- ‚úÖ **Error handling** and edge case validation
- ‚úÖ **Backward compatibility** ensuring existing tools continue to work

## üèóÔ∏è Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Claude Code   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  MCP Metatool    ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  MCP Servers    ‚îÇ
‚îÇ     Client      ‚îÇ    ‚îÇ     Server       ‚îÇ    ‚îÇ (GitHub, Slack, ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ                  ‚îÇ    ‚îÇ  Database, etc) ‚îÇ
                       ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ ‚îÇ   Starlark   ‚îÇ ‚îÇ
                       ‚îÇ ‚îÇ   Runtime    ‚îÇ ‚îÇ
                       ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
                       ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
                       ‚îÇ ‚îÇ Saved Tools  ‚îÇ ‚îÇ
                       ‚îÇ ‚îÇ   Storage    ‚îÇ ‚îÇ
                       ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Components:**
- **üîó Proxy Manager**: Connects to and manages multiple MCP servers
- **üêç Starlark Runtime**: Executes Python-like scripts with server access
- **üõ†Ô∏è Tool Bridge**: Exposes MCP tools as callable Starlark functions
- **üíæ Persistence Layer**: Stores and manages saved tool definitions
- **‚úÖ Validation Engine**: JSON Schema validation for tool parameters

## üìä Project Structure

```
‚îú‚îÄ‚îÄ main.go                         # Server setup and initialization
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/                     # MCP server configuration
‚îÇ   ‚îú‚îÄ‚îÄ persistence/                # Tool storage and management
‚îÇ   ‚îú‚îÄ‚îÄ proxy/                      # MCP server connection management
‚îÇ   ‚îú‚îÄ‚îÄ starlark/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ executor.go             # Starlark execution engine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bridge.go               # MCP tool integration ‚≠ê
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ convert.go              # Go‚ÜîStarlark value conversion
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bridge_test.go          # Integration tests (36 tests)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ executor_test.go        # Execution tests (400+ tests)
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ eval.go                 # eval_starlark with proxy support ‚≠ê
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ saved.go                # Saved tools with proxy support ‚≠ê
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ integration_test.go     # End-to-end tests (15 tests)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [other tool handlers]
‚îÇ   ‚îî‚îÄ‚îÄ validation/                 # JSON Schema validation
‚îî‚îÄ‚îÄ spec.md                         # Complete technical specification
```

*‚≠ê = New/Enhanced for Starlark integration*

## Storage

### Directory Structure

The metatool uses a single directory for all persistent data:

```
~/.mcp-metatool/              # Default directory (or $MCP_METATOOL_DIR)
‚îú‚îÄ‚îÄ servers.json              # MCP server configuration
‚îî‚îÄ‚îÄ tools/                    # Saved tool definitions
    ‚îú‚îÄ‚îÄ greet_user.json      # Individual tool files
    ‚îú‚îÄ‚îÄ data_processor.json
    ‚îî‚îÄ‚îÄ ...
```

- **Saved tools**: Stored as JSON files in `tools/` subdirectory
- **Server config**: Single `servers.json` file for MCP server connections
- **Environment override**: Use `MCP_METATOOL_DIR` to customize location

## üó∫Ô∏è Roadmap

### ‚úÖ Completed Milestones

**Phase 1 - Foundation (Complete)**
- ‚úÖ MCP server discovery and connection management
- ‚úÖ Basic tool proxying with `serverName__toolName` format
- ‚úÖ File-based persistence and configuration

**Phase 2 - Starlark Integration (Complete)** 
- ‚úÖ **Starlark runtime** with full Python-like language support
- ‚úÖ **Tool bridge** enabling `serverName.toolName(params)` syntax
- ‚úÖ **Composite tool creation** with save_tool functionality
- ‚úÖ **Parameter validation** using JSON Schema
- ‚úÖ **Comprehensive testing** with 450+ test cases

### üöß Current Focus

**Phase 2.5 - Production Hardening**
- üîÑ Performance profiling and optimization
- üîÑ Enhanced error messages and debugging support
- üîÑ Tool execution metrics and monitoring

### üìã Future Enhancements  

**Phase 3 - Advanced Features**
- ‚è±Ô∏è **Execution timeouts** and resource limits for composite tools
- üìä **Audit trails** and execution logging for compliance
- üîÑ **Tool versioning** and migration support
- üéØ **Performance optimizations** for high-volume usage

**Phase 4 - Ecosystem Integration**
- üåê **Tool marketplace** for sharing composite tools
- üîå **Plugin system** for custom integrations
- üìà **Analytics dashboard** for tool usage insights
- ü§ù **Collaboration features** for team tool development

## ü§ù Contributing

Built with ‚ù§Ô∏è using:
- [Official MCP Go SDK](https://github.com/modelcontextprotocol/go-sdk)
- [Starlark in Go](https://pkg.go.dev/go.starlark.net/starlark)

The MCP Metatool represents a major evolution in tool composition, transforming the MCP ecosystem from individual tools into a unified **composition platform**. 

**Ready to build the future of tool automation? Let's compose! üöÄ**